name: Generate IP Lists - Upload to CloudFlare

on:
  push:
    branches:
     - main
    paths:
      - './all_botsonly.ips'
      - '!.github/workflows/**'
      - '!renovate.json'
  workflow_dispatch:

jobs:
  UpdateCloudFlare:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: whois
          version: 1.0

      - name: Ensure jq is available
        run: sudo apt-get update && sudo apt-get install -y jq

      # --- (1) CLEAR the list completely ---
      - name: Clear Cloudflare list (set to empty)
        id: cf_clear
        shell: bash
        env:
          CF_API: https://api.cloudflare.com/client/v4
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_LIST_ID: ${{ secrets.CF_LIST_ID }}
          CF_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          set -euo pipefail
          RESP=$(curl -sS -X PUT \
            -H "Authorization: Bearer ${CF_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '[]' \
            "${CF_API}/accounts/${CF_ACCOUNT_ID}/rules/lists/${CF_LIST_ID}/items")
          echo "$RESP" | jq .
          OP_ID=$(echo "$RESP" | jq -r '.result.operation_id // empty')
          [ -n "$OP_ID" ] || { echo "No operation_id from clear"; exit 1; }
          echo "operation_id=${OP_ID}" >> "$GITHUB_OUTPUT"

      - name: Wait for Cloudflare clear op
        shell: bash
        env:
          CF_API: https://api.cloudflare.com/client/v4
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          OP_ID: ${{ steps.cf_clear.outputs.operation_id }}
        run: |
          set -euo pipefail
          for i in $(seq 1 60); do
            r=$(curl -sS -H "Authorization: Bearer ${CF_TOKEN}" \
              "${CF_API}/accounts/${CF_ACCOUNT_ID}/rules/lists/bulk_operations/${OP_ID}")
            status=$(echo "$r" | jq -r '.result.status // .status // "unknown"')
            echo "Clear op status: $status"
            case "$status" in
              completed) exit 0 ;;
              failed) echo "$r" | jq .; exit 1 ;;
            esac
            sleep 5
          done
          echo "Timed out waiting for clear operation ${OP_ID}"; exit 1

      # --- (2) Build CSV and DEDUPE across all files (merge comments) ---
      - name: Build consolidated CSV with list names
        shell: bash
        env:
          OUT_CSV: ${{ github.workspace }}/cloudflare_items.csv
        run: |
          set -euo pipefail
          echo "value,description" > "$OUT_CSV"
          shopt -s nullglob
          for f in "$GITHUB_WORKSPACE"/iplists-botsonly/*.ips; do
            name="$(basename "$f" .ips)"
            # each line → value,description
            awk 'NF{gsub(/\r$/,""); print}' "$f" \
              | awk -v desc="$name" 'NF{print $0","desc}' >> "$OUT_CSV"
          done
          echo "CSV built: $OUT_CSV"

      - name: Convert CSV to JSON (stable; v4+v6, /32 & /128, validate, dedupe, merge comments)
        id: make_json
        shell: bash
        env:
            IN_CSV: ${{ github.workspace }}/cloudflare_items.csv
            IPS_DIR: ${{ github.workspace }}/iplists-botsonly
        run: |
            set -euo pipefail

            TMP_DIR="${RUNNER_TEMP:-/tmp}"
            mkdir -p "$TMP_DIR"
            STREAM="$TMP_DIR/stream.tsv"
            ITEMS="$TMP_DIR/items.json"
            : > "$STREAM"

            echo "🔎 Inputs:"
            echo " - CSV: $IN_CSV"
            echo " - DIR: $IPS_DIR"

            # Decide mode (default ips to satisfy `set -u`)
            INPUT_MODE="ips"
            if [[ -f "$IN_CSV" && $(wc -l < "$IN_CSV" || echo 0) -gt 1 ]]; then
            INPUT_MODE="csv"
            echo "➡️ Using CSV"
            tail -n +2 "$IN_CSV" || true \
            | awk -F, '
                {
                    val=$1; desc=$2;
                    for(i=3;i<=NF;i++) desc=desc","$i;
                    gsub(/\r$/,"",desc);
                    gsub(/^[ \t]+|[ \t]+$/,"",val);
                    gsub(/^[ \t]+|[ \t]+$/,"",desc);
                    gsub(/\t/, "", val);  # strip tabs
                    gsub(/\t/, "", desc); # strip tabs
                    if (val!="") print val "\t" desc;
                }' >> "$STREAM"
            fi

            # Also load *.ips (we combine both sources to be safe)
            if [[ -d "$IPS_DIR" ]]; then
            shopt -s nullglob
            IPS_FILES=( "$IPS_DIR"/*.ips )
            echo "➡️ Found ${#IPS_FILES[@]} .ips files"
            for f in "${IPS_FILES[@]}"; do
                name="$(basename "$f" .ips)"
                awk '
                { gsub(/\r$/,""); line=$0 }
                { sub(/^[ \t]+/, "", line); sub(/[ \t]+$/, "", line) }
                { sub(/[ \t]+#.*$/, "", line); if (line ~ /^#/) line="" }
                length(line)>0 { print line }
                ' "$f" \
                | awk -v desc="$name" '
                    NF{
                    gsub(/\t/, "", $0);      # strip tabs from value
                    gsub(/\t/, "", desc);    # strip tabs from desc
                    print $0 "\t" desc
                    }
                ' >> "$STREAM"
            done
            fi

            TOTAL=$(wc -l < "$STREAM" || echo 0)
            echo "📦 Candidates before validation: $TOTAL"
            if [[ "$TOTAL" -eq 0 ]]; then
            echo "❌ No candidate values to process."
            exit 1
            fi

            # --- Minimal, robust jq (no side-channel logging) ---
            jq -R '
            def ipv4: "^([0-9]{1,3}\\.){3}[0-9]{1,3}(?:/(?:[0-9]|[12][0-9]|3[0-2]))?$";
            def ipv6_loose: "^[0-9A-Fa-f:.]+(?:/[0-9]{1,3})?$";
            def v6_prefix: if test(".*/") then (capture(".*/(?<p>[0-9]+)$").p|tonumber) else null end;
            def has_zone: test("%");

            def classify($desc):
                if has_zone then {ip:., comment:$desc, ok:false}
                elif test(ipv4) then
                if contains("/") then {ip:., comment:$desc, ok:true}
                else {ip:(. + "/32"), comment:$desc, ok:true}          # bare IPv4 -> /32
                end
                elif test(ipv6_loose) then
                ( . as $ip
                | ($ip|ascii_downcase) as $low
                | ($low|v6_prefix) as $p
                | if $p==null then {ip:($low + "/128"), comment:$desc, ok:true}   # bare IPv6 -> /128
                    elif ($p>=12 and $p<=128) then {ip:$low, comment:$desc, ok:true}
                    else {ip:$low, comment:$desc, ok:false}
                    end)
                else {ip:., comment:$desc, ok:false}
                end;

            [ inputs
                | select(length>0)
                | ( . / "\t" ) as $p
                | ($p[0] // "") as $v
                | ($p[1] // "") as $desc
                | ($v | gsub("\\s+"; "")) as $v2
                | ($v2 | classify($desc))
            ]
            | map(select(.ok))
            | sort_by(.ip)
            | group_by(.ip)
            | map({ ip: .[0].ip,
                    comment: ( [.[].comment] | map(select(length>0)) | unique | join(", ") ) })
            ' < "$STREAM" > "$ITEMS"

            if [[ ! -s "$ITEMS" ]]; then
            echo "❌ No valid items produced."
            echo "👀 First 20 raw lines:"; head -n 20 "$STREAM" || true
            exit 1
            fi

            echo "✅ Unique items to upload: $(jq 'length' "$ITEMS")"
            echo "items_json=$ITEMS" >> "$GITHUB_OUTPUT"
            echo "Preview:"; jq '.[0:5]' "$ITEMS"

      - name: Build rejects list (optional)
        if: always()
        shell: bash
        env:
            STREAM_PATH: ${{ runner.temp }}/stream.tsv
        run: |
            set -euo pipefail
            OUT="${RUNNER_TEMP}/rejected_ipv6_cidrs.txt"
            : > "$OUT"
            jq -R '
            def ipv4: "^([0-9]{1,3}\\.){3}[0-9]{1,3}(?:/(?:[0-9]|[12][0-9]|3[0-2]))?$";
            def ipv6_loose: "^[0-9A-Fa-f:.]+(?:/[0-9]{1,3})?$";
            def v6_prefix: if test(".*/") then (capture(".*/(?<p>[0-9]+)$").p|tonumber) else null end;
            def has_zone: test("%");
            def bad:
                if has_zone then true
                elif test(ipv4) then false
                elif test(ipv6_loose) then ((. | v6_prefix) as $p | ($p!=null and $p<12))
                else true
                end;
            [inputs
                | select(length>0)
                | ( . / "\t" ) as $p
                | ($p[0] // "") as $v
                | ($v | gsub("\\s+"; "")) as $v2
                | select($v2 | bad)
            ] | .[]
            ' < "$STREAM_PATH" > "$OUT" || true
            echo "Rejects (if any): $(wc -l < "$OUT" || echo 0)"
          
      # --- (3) Upload unique items and wait for completion ---
      - name: Update Cloudflare list (replace all items)
        id: cf_put
        shell: bash
        env:
          CF_API: https://api.cloudflare.com/client/v4
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_LIST_ID: ${{ secrets.CF_LIST_ID }}
          CF_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          ITEMS_JSON: ${{ steps.make_json.outputs.items_json }}
        run: |
          set -euo pipefail
          RESP=$(curl -sS -X PUT \
            -H "Authorization: Bearer ${CF_TOKEN}" \
            -H "Content-Type: application/json" \
            --data @"${ITEMS_JSON}" \
            "${CF_API}/accounts/${CF_ACCOUNT_ID}/rules/lists/${CF_LIST_ID}/items")
          echo "$RESP" | jq .
          OP_ID=$(echo "$RESP" | jq -r '.result.operation_id // empty')
          [ -n "$OP_ID" ] || { echo "No operation_id returned"; echo "$RESP" | jq '.errors'; exit 1; }
          echo "operation_id=${OP_ID}" >> "$GITHUB_OUTPUT"

      - name: Wait for Cloudflare bulk operation
        shell: bash
        env:
          CF_API: https://api.cloudflare.com/client/v4
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          OP_ID: ${{ steps.cf_put.outputs.operation_id }}
        run: |
          set -euo pipefail
          for i in $(seq 1 60); do
            r=$(curl -sS -H "Authorization: Bearer ${CF_TOKEN}" \
              "${CF_API}/accounts/${CF_ACCOUNT_ID}/rules/lists/bulk_operations/${OP_ID}")
            status=$(echo "$r" | jq -r '.result.status // .status // "unknown"')
            echo "Bulk op status: $status"
            case "$status" in
              completed) exit 0 ;;
              failed) echo "$r" | jq .; exit 1 ;;
            esac
            sleep 5
          done
          echo "Timed out waiting for bulk operation ${OP_ID}"; exit 1